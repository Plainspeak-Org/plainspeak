# Creating PlainSpeak Plugins

This guide will walk you through the process of creating plugins for PlainSpeak, allowing you to extend its functionality with new capabilities.

## Overview

A PlainSpeak plugin is a module that extends the system's ability to understand and execute specific types of commands. Plugins can:

- Register new verbs that PlainSpeak can recognize
- Translate those verbs into concrete shell commands or API calls
- Provide custom execution logic for complex operations
- Add specialized functionality for specific domains

## Plugin Basics

### Plugin Structure

A typical PlainSpeak plugin consists of:

1. **Metadata**: Name, description, and version information
2. **Verbs**: The natural language actions this plugin understands
3. **Command Templates**: Jinja2 templates for generating commands
4. **Execution Logic**: Optional Python code for command generation and execution

### Plugin Types

PlainSpeak supports two main types of plugins:

1. **YAML Plugins**: Simple plugins defined in YAML files
2. **Python Plugins**: More complex plugins with custom logic

## Creating a YAML Plugin

YAML plugins are the simplest to create and are ideal for straightforward command mappings.

### Basic Structure

Create a file named `your-plugin.yaml` with this structure:

```yaml
name: your-plugin
description: Description of what your plugin does
version: 1.0.0
author: Your Name
verbs:
  - verb1
  - verb2
  - verb3
commands:
  verb1:
    template: "command1 {{ arg1 }} {{ arg2 }}"
    description: Description of what verb1 does
    examples:
      - "verb1 with some arguments"
  verb2:
    template: "command2 {{ arg1 }}"
    description: Description of what verb2 does
    examples:
      - "verb2 with an argument"
  verb3:
    template: |
      # For multi-line commands
      echo "Starting operation"
      command3 {{ arg1 }} {{ arg2 }}
      echo "Operation complete"
    description: Description of what verb3 does
    examples:
      - "verb3 with multiple arguments"
```

### Jinja2 Templates

The `template` fields use Jinja2 templating syntax to map natural language to concrete commands:

```yaml
commands:
  search:
    template: "grep -r \"{{ pattern }}\" {{ location | default('.') }}"
    description: "Search for a pattern in files"
    examples:
      - "search for 'TODO' in the src directory"
```

With this template, a natural language command like "search for 'error' in log files" might be translated to:
```bash
grep -r "error" ./logs
```

### Template Variables

Variables in templates come from the AST generated by PlainSpeak's parser. Common variables include:

- Basic arguments extracted from the natural language command
- Default values when arguments are missing
- Contextual information like current directory

### Filters and Conditionals

You can use Jinja2 filters and conditionals to create more dynamic templates:

```yaml
commands:
  find:
    template: >
      find {{ path | default('.') }}
      {% if type %}
      -type {{ type }}
      {% endif %}
      {% if name %}
      -name "{{ name }}"
      {% endif %}
      {% if size %}
      -size {{ size }}
      {% endif %}
    description: "Find files matching criteria"
    examples:
      - "find large PDF files in the Documents folder"
```

### Installing a YAML Plugin

To install a YAML plugin:

1. Place your `.yaml` file in `~/.config/plainspeak/plugins/`
2. Restart PlainSpeak or run `plainspeak reload-plugins`

## Creating a Python Plugin

For more complex functionality, create a Python plugin:

### Basic Structure

Create a file named `your_plugin.py`:

```python
from plainspeak.plugins.base import Plugin, registry

class YourPlugin(Plugin):
    def __init__(self):
        super().__init__(
            name="your-plugin",
            description="Description of what your plugin does",
            version="1.0.0"
        )

    def get_verbs(self):
        """Return a list of verbs this plugin can handle."""
        return ["verb1", "verb2", "verb3"]

    def generate_command(self, verb, args):
        """Generate a command string for the given verb and arguments."""
        if verb == "verb1":
            return f"command1 {args.get('arg1', '')} {args.get('arg2', '')}"
        elif verb == "verb2":
            return f"command2 {args.get('arg1', '')}"
        elif verb == "verb3":
            return f"""
                echo "Starting operation"
                command3 {args.get('arg1', '')} {args.get('arg2', '')}
                echo "Operation complete"
            """
        return None  # Return None if verb not supported

# Register the plugin
registry.register(YourPlugin())
```

### Advanced Plugin Features

Python plugins can implement more advanced features:

#### Custom Command Execution

You can override the default command execution:

```python
def execute_command(self, verb, args, command):
    """Execute a command directly instead of passing to the shell."""
    if verb == "special-verb":
        # Custom execution logic
        result = self._custom_api_call(args)
        return result
    # For other verbs, let PlainSpeak handle execution
    return None
```

#### Command Validation

You can validate commands before execution:

```python
def validate_command(self, verb, args, command):
    """Validate a command before execution."""
    if verb == "risky-verb" and not args.get("force"):
        return False, "This operation is risky. Add 'force' to confirm."
    return True, None
```

#### Using Jinja2 Templates in Python Plugins

You can still use Jinja2 templates in Python plugins for more readable command generation:

```python
from jinja2 import Template

class YourPlugin(Plugin):
    # ...

    def __init__(self):
        super().__init__("your-plugin", "Your plugin description")
        self.templates = {
            "verb1": Template("command1 {{ arg1 }} {{ arg2 }}"),
            "verb2": Template("command2 {{ arg1 }}"),
        }

    def generate_command(self, verb, args):
        if verb in self.templates:
            return self.templates[verb].render(args)
        return None
```

### Installing a Python Plugin

To install a Python plugin:

1. Place your `.py` file in `~/.config/plainspeak/plugins/`
2. Restart PlainSpeak or run `plainspeak reload-plugins`

## Advanced Plugin Development

### Handling Command Arguments

The `args` dictionary contains parameters extracted from the natural language command. You should handle missing arguments gracefully:

```python
def generate_command(self, verb, args):
    path = args.get("path", ".")  # Default to current directory if path not specified
    pattern = args.get("pattern", "*")  # Default pattern

    return f"find {path} -name '{pattern}'"
```

### Working with the AST

For more complex parsing, you can work with the Abstract Syntax Tree directly:

```python
def generate_command(self, verb, args, ast=None):
    if ast and ast.has_node("filter"):
        filter_node = ast.get_node("filter")
        # Process filter conditions
        # ...

    # Generate command based on AST analysis
    return command
```

### Plugin Configuration

Plugins can have their own configuration sections in the PlainSpeak config file:

```python
def __init__(self):
    super().__init__("your-plugin", "Your plugin description")
    # Load plugin configuration
    self.config = self.load_config()

def load_config(self):
    # Access the global config via registry
    config = registry.get_config()
    if config and "plugins" in config and "your-plugin" in config["plugins"]:
        return config["plugins"]["your-plugin"]
    # Return default config if not found
    return {"default_setting": "default_value"}
```

The configuration might look like:

```toml
[plugins.your-plugin]
setting1 = "value1"
setting2 = "value2"
```

### Plugin Dependencies

If your plugin requires external Python packages:

```python
def __init__(self):
    super().__init__("your-plugin", "Your plugin description")
    self.dependencies = ["requests", "beautifulsoup4"]

    # Check dependencies
    self.check_dependencies()

def check_dependencies(self):
    """Verify all required dependencies are installed."""
    missing = []
    for dep in self.dependencies:
        try:
            __import__(dep)
        except ImportError:
            missing.append(dep)

    if missing:
        print(f"Warning: Your plugin is missing these dependencies: {', '.join(missing)}")
        print(f"Install them with: pip install {' '.join(missing)}")
```

## Packaging and Distribution

To share your plugin with others, you can create a proper Python package:

### Package Structure

```
plainspeak-plugin-yourname/
├── pyproject.toml
├── README.md
├── LICENSE
└── src/
    └── plainspeak_plugin_yourname/
        ├── __init__.py
        └── plugin.py
```

### Entry Points

In your `pyproject.toml`, use entry points to register your plugin:

```toml
[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "plainspeak-plugin-yourname"
version = "1.0.0"
description = "Your plugin description"
readme = "README.md"
requires-python = ">=3.9"
license = {text = "MIT"}
dependencies = [
    "plainspeak>=1.0.0",
    # Add your dependencies
]

[project.entry-points."plainspeak.plugins"]
yourname = "plainspeak_plugin_yourname.plugin:register"
```

In your `src/plainspeak_plugin_yourname/__init__.py`:

```python
from . import plugin
```

In your `src/plainspeak_plugin_yourname/plugin.py`:

```python
from plainspeak.plugins.base import Plugin, registry

class YourPlugin(Plugin):
    # Your plugin implementation
    pass

def register():
    """Register the plugin with PlainSpeak."""
    registry.register(YourPlugin())
```

### Publishing to PyPI

Build and publish your package:

```bash
python -m build
python -m twine upload dist/*
```

Users can then install your plugin with:

```bash
pip install plainspeak-plugin-yourname
```

PlainSpeak will automatically discover and load your plugin.

## Best Practices

### Documentation

Document your plugin thoroughly:

- Include a README.md with installation and usage instructions
- Provide clear examples of natural language commands your plugin supports
- Document any configuration options
- Explain any dependencies or requirements

### Error Handling

Implement robust error handling:

```python
def generate_command(self, verb, args):
    try:
        # Command generation logic
        return command
    except KeyError as e:
        # Missing required argument
        return f"echo 'Error: Missing required argument {e}'"
    except Exception as e:
        # Other error
        return f"echo 'Error: {str(e)}'"
```

### Command Safety

Consider safety in your command generation:

- Sanitize user inputs to prevent command injection
- Use `shlex.quote()` to properly escape shell arguments
- Avoid dangerous commands by default
- Implement confirmation for risky operations

### Testing

Test your plugin thoroughly:

```python
import unittest
from plainspeak.plugins.base import registry
from your_plugin import YourPlugin

class TestYourPlugin(unittest.TestCase):
    def setUp(self):
        self.plugin = YourPlugin()

    def test_get_verbs(self):
        verbs = self.plugin.get_verbs()
        self.assertIn("verb1", verbs)

    def test_generate_command(self):
        cmd = self.plugin.generate_command("verb1", {"arg1": "test"})
        self.assertEqual(cmd, "command1 test ")
```

## Example Plugins

### A Weather Plugin

```python
import requests
from plainspeak.plugins.base import Plugin, registry

class WeatherPlugin(Plugin):
    def __init__(self):
        super().__init__("weather", "Get weather information")

    def get_verbs(self):
        return ["weather", "forecast", "temperature"]

    def generate_command(self, verb, args):
        location = args.get("location", "")
        if not location:
            return "echo 'Please specify a location'"

        if verb == "weather":
            return f"curl wttr.in/{location}?format=3"
        elif verb == "forecast":
            return f"curl wttr.in/{location}"
        elif verb == "temperature":
            return f"curl wttr.in/{location}?format=%t"

        return None

registry.register(WeatherPlugin())
```

### A Calculator Plugin

```python
import re
from plainspeak.plugins.base import Plugin, registry

class CalculatorPlugin(Plugin):
    def __init__(self):
        super().__init__("calculator", "Perform calculations")

    def get_verbs(self):
        return ["calculate", "compute", "eval"]

    def generate_command(self, verb, args):
        expression = args.get("expression", "")
        if not expression:
            return "echo 'Please provide an expression to calculate'"

        # Sanitize the expression to prevent command injection
        if not self._is_safe_expression(expression):
            return "echo 'Invalid or unsafe expression'"

        return f"echo '{expression}' | bc -l"

    def _is_safe_expression(self, expr):
        # Only allow basic math operations and numbers
        return bool(re.match(r'^[\d\s\+\-\*\/\(\)\.]+$', expr))

registry.register(CalculatorPlugin())
```

## Conclusion

Creating plugins for PlainSpeak is a powerful way to extend its capabilities to new domains. Whether you're creating a simple YAML plugin or a complex Python module, the plugin system provides flexibility to integrate with any command-line tool or API.

Remember these key points:

1. **Start Simple**: Begin with a basic plugin that handles a few verbs
2. **Test Thoroughly**: Ensure your plugin works with a variety of natural language inputs
3. **Document Well**: Provide clear documentation and examples
4. **Share Wisely**: Package and share your plugin with the community

For more information and examples, check out the [PlainSpeak Plugin Repository](https://github.com/cschanhniem/plainspeak-plugins) and the [Plugin API Reference](../api/plugin_api.md).

Happy plugin development!
